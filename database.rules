service cloud.firestore {
  match /databases/{database}/documents {
    
    // Helper function to check if the viewer follows the author
    function isFollowing(authorId) {
      return exists(/databases/$(database)/documents/users/$(authorId)/followers/$(request.auth.uid));
    }

    // 1. Username Uniqueness [NEW]
    // Doc ID is the lowercase username. Only the owner can create it.
    match /usernames/{username} {
      allow read: if true;
      allow create: if request.auth != null && request.resource.data.uid == request.auth.uid;
      allow delete: if request.auth != null && resource.data.uid == request.auth.uid;
    }

    // 2. Products: Affiliate Store (Publicly readable)
    match /products/{productId} {
      allow read: if true;
      allow write: if request.auth != null && request.auth.token.role == "admin";
    }

    // 3. Users & Social Graph
    match /users/{userId} {
      // Profiles are public for search/discovery
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.auth.uid == userId;
      allow update: if request.auth != null && (
        request.auth.uid == userId ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['followersCount'])
      );
      allow delete: if request.auth != null && request.auth.uid == userId;

      // Followers and Following sub-collections
      match /followers/{followerId} {
        allow read: if request.auth != null;
        // Users can add themselves to someone else's followers (Following them)
        allow write: if request.auth != null && request.auth.uid == followerId;
      }
      
      match /following/{followedId} {
        allow read: if request.auth != null;
        // Users can only manage their own following list
        allow write: if request.auth != null && request.auth.uid == userId;
      }

      // Private Medical Records
      match /medical_records/{recordId} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
      
      // Other private sub-collections
      match /{allSubcollections=**} {
        allow read, write: if request.auth != null && request.auth.uid == userId;
      }
    }

    // 4. Petbook Posts (with Visibility Logic)
    match /posts/{postId} {
      // Visibility Logic:
      // Public: Anyone logged in
      // Friends: Only if viewer is in author's followers sub-collection
      // Private: Only the author
      allow read: if request.auth != null && (
        resource.data.visibility == 'public' ||
        resource.data.userId == request.auth.uid ||
        (resource.data.visibility == 'friends' && isFollowing(resource.data.userId))
      );
      
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      
      allow update: if request.auth != null && (
        resource.data.userId == request.auth.uid || 
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['likes'])
      );
    }

    // 5. Comments & PetOra (Existing logic maintained)
    match /comments/{commentId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
    }

    match /questions/{questionId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes', 'answerCount'])
      );
    }

    match /answers/{answerId} {
      allow read: if request.auth != null;
      allow create: if request.auth != null && (
          request.resource.data.userId == request.auth.uid ||
          request.resource.data.userId == "AI_ASSISTANT" 
      );
      allow update: if request.auth != null && (
        resource.data.userId == request.auth.uid ||
        request.resource.data.diff(resource.data).affectedKeys().hasOnly(['upvotes'])
      );
    }
  }
}